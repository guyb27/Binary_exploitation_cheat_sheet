import Von_neumann_arch from '../assets/image/von_neumann_arch.jpg'
import Memory_structure from '../assets/image/memory_structure.jpg'
import Nasm_structure from '../assets/image/nasm_structure.jpg'
import Bitwise from '../assets/image/bitwise.png'
import Gdb_taken from '../assets/image/gdb_taken.png'
import Asm_taken from '../assets/image/asm_taken.png'
import Next_functions from '../assets/image/next_functions.png'
import Stack_alignment from '../assets/image/stack_alignment.png'
import Code_to_shellcode from '../assets/image/code_to_shellcode.png'
import Shellcode_to_code from '../assets/image/shellcode_to_code.png'
import Exec_shellcode from '../assets/image/exec_shellcode.png'
import Shellcode_to_elf from '../assets/image/shellcode_to_elf.png'
import Shellcode_array from '../assets/image/shellcode_array.png'
import Shellcode_exemple_code from '../assets/image/shellcode_exemple_code.png'
import Shellcode_requirement from '../assets/image/shellcode_requirement.png'
import Parametres_main from '../assets/image/Parametres_main.png'
import Get_saved_eip from '../assets/image/get_saved_eip.png'

export default function Cybersecurity() {
    return (
        <>
            <div style={{marginLeft: "70px", marginRight: "70px"}}>
                <h1 style={{textAlign: "center"}}>Binary exploitation</h1>
                <br/>
                <h2>Les registres chez Linux:</h2>
                <p>EIP: Extended Instruction Pointer</p>
                <p>ESP: Extended Stack Pointer ??IL POINTE SUR L'ADRESSE DE LA DERNIERE VALEUR QUI EST PUSH SUR LA STACK??</p>
                <p>EBP: Extended Base Pointer ??POINTEUR SUR LE DEBUT DE LA STACK??</p>
                <p>EAX: The return of the last instruction</p>
                <p>EBX: </p>
                <p>EDI: Destination or 1th argument to functions</p>
                <p>ESI: 2th argument to function</p>
                <p>EDX: 3th argument to functions, 2th return register</p>
                <p>ECX: Counter or 4th integer argument to functions</p>
                <p>r8: 5th integer argument to functions</p>
                <p>r9: 6th integer argument to functions</p>
                <p>r10: Temporary register, used for passing a function's static chain pointer</p>
                <p>r11: temporary register</p>
                <p>r12-15: Called save pointers</p>
                <p>r: </p>
                <p>r: </p>
                <br/>
                <hr style={{height:"2px", width:"50%", borderWidth:"0", color:"red", backgroundColor:"red"}}/>
                <br/>
                <h1 style={{textAlign: "center"}}>Formation:</h1>
                <br/>
                <p>https://institute.sektor7.net/</p>
                <p>https://courses.zero2auto.com/</p>
                <br/>
                <hr style={{height:"2px", width:"50%", borderWidth:"0", color:"red", backgroundColor:"red"}}/>
                <br/>
                <h1 style={{textAlign: "center"}}>Doc:</h1>
                <br/>
                <p>https://z0mbie.dreamhosters.com/</p>
                <p>https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/</p>
                <p>https://blog.packagecloud.io/the-definitive-guide-to-linux-system-calls/</p>
                <p><a href='https://www.unilim.fr/pages_perso/tristan.vaccon/cours_nasm.pdf'>Un cours d'asm en francais d un etudiant en license</a></p>
                <p><a href='https://software.intel.com/content/www/us/en/develop/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4.html'>La bible</a></p>
                <br/>
                <hr style={{height:"2px", width:"50%", borderWidth:"0", color:"red", backgroundColor:"red"}}/>
                <br/>
                <br/>
                <h1 style={{textAlign: "center"}}>Architecture Von Neumann d un binaire:</h1>
                <br/>
                <h2>Composition d'un binaire:</h2>
                <br/>
                <div className='row'  style={{textAlign: "center"}}>
                    <div className='col'>
                        <img src={Von_neumann_arch} alt="Von_neumann_arch"/>
                    </div>
                </div>
                <br/>
                <p style={{padding:"0 0 0 40px", fontWeight: "bold"}}>
                    Central Processing Unit (CPU) (unité centrale de traitement/Processeur)<br/>
                </p>
                <p style={{padding:"0 0 0 80px", position:"relative", top: "-10px", color: "red"}}>
                    _Control Unit (CU) (unité de contrôle)<br/>
                    _Arithmetic/Logic Unit (ALU) (unité arithmétique/logique)<br/>
                    _Registers (registres)<br/>
                </p>
                <p style={{padding:"0 0 0 40px", fontWeight: "bold"}}>
                    Memory Unit (unité de mémoire) (Mémoire primaire)<br/>
                </p>
                <p style={{padding:"0 0 0 80px", position:"relative", top: "-10px", color: "red"}}>
                    _Cache:
                </p>
                <p style={{padding:"0 0 0 100px", position:"relative", top: "-10px", color: "green"}}>
                    Cache Level 1 : Généralement en kilo-octets, la mémoire disponible la plus rapide, située dans chaque cœur de processeur. (Seuls les registres sont plus rapides.)<br/>
                    Cache Level 2 : Généralement en mégaoctets, extrêmement rapide (mais plus lent que L1), partagé entre tous les cœurs du processeur. <br/>
                    Cache Level 3 : Généralement en mégaoctets (plus grand que L2), plus rapide que la RAM mais plus lent que L1/L2. (Tous les processeurs n'utilisent pas L3.) <br/><br/>
                </p>
                <p style={{padding:"0 0 0 80px", position:"relative", top: "-10px", color: "red"}}>
                    _Random Access Memory (RAM):
                </p>
                <p style={{padding:"0 0 0 100px", position:"relative", top: "-10px", color: "green"}}>
                    Stack/Pile (Mémoire statique) : A une conception Last-in First-out (LIFO) et est de taille fixe. Les données qu'il contient ne sont accessibles que dans un ordre spécifique en poussant et en popant les données. <br/>
                    Heap/Tas (Mémoire dynamique/Malloc) : A une conception hiérarchique et est donc beaucoup plus grand et plus polyvalent dans le stockage des données, car les données peuvent être stockées et récupérées dans n'importe quel ordre. Cependant, cela rend le tas plus lent que la pile.<br/>
                    Data : Comporte deux parties : .data, qui sont utilisées pour contenir les variables afféctées dès leurs créations, et .bss, qui est utilisé pour contenir les variables non affectées (c'est-à-dire la mémoire tampon pour une allocation ultérieure). <br/>
                    Text : Les instructions d'assemblage principales sont chargées dans ce segment pour être récupérées et exécutées par le CPU. 
                </p>
                <div className='row'  style={{textAlign: "center"}}>
                    <div className='col'>
                        <img src={Memory_structure} alt="Memory_structure"/>
                    </div>
                </div>
                <br/>
                <p style={{padding:"0 0 0 40px", fontWeight: "bold"}}>
                    Input/Output Devices (périphériques d'entrée/sortie):
                </p>
                <p style={{padding:"0 0 0 80px", position:"relative", top: "-10px", color: "red"}}>
                    _Mass Storage Unit (unité de stockage de masse) (Mémoire secondaire)<br/>
                    _Keyboard (clavier)<br/>
                    _Display (afficher)
                </p>
                <br/>
                <h2>Vitesse:</h2>
                <br/>
                <table className="table">
                    <thead>
                        <tr>
                        <th scope="col">Composant</th>
                        <th scope="col">Vitesse</th>
                        <th scope="col">Taille</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                        <th scope="row">Registres</th>
                        <td>Le plus rapide</td>
                        <td>Bytes</td>
                        </tr>
                        <tr>
                        <th scope="row">L1 cache</th>
                        <td>Le plus rapide apres les registres</td>
                        <td>Kilobytes</td>
                        </tr>
                        <tr>
                        <th scope="row">L2 cache</th>
                        <td>Very fast</td>
                        <td>Megabytes</td>
                        </tr>
                        <tr>
                        <th scope="row">L3 cache</th>
                        <td>Rapide, mais plus lent que ci-dessus </td>
                        <td>Megabytes</td>
                        </tr>
                        <tr>
                        <th scope="row">RAM</th>
                        <td>Beaucoup plus lent que tout ce qui précède </td>
                        <td>Gigabytes-Terabytes</td>
                        </tr>
                        <tr>
                        <th scope="row">Stockage</th>
                        <td>Le plus lent</td>
                        <td>Terabytes et plus</td>
                        </tr>
                    </tbody>
                </table>
                <br/>
                <h2>Architectures de jeux d'instructions :</h2>
                <br/>
                <table className="table">
                    <thead>
                        <tr>
                        <th scope="col">Composant</th>
                        <th scope="col">Description</th>
                        <th scope="col">Exemple</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                        <th scope="row">Instructions</th>
                        <td>L'instruction à traiter au format opcode operand_list. Il y a généralement 1, 2 ou 3 opérandes séparés par des virgules. </td>
                        <td>add rax, 1, mov rsp, rax, push rax</td>
                        </tr>
                        <tr>
                        <th scope="row">Registres</th>
                        <td>Utilisé pour stocker temporairement des opérandes, des adresses ou des instructions. </td>
                        <td>rax, rsp, rip</td>
                        </tr>
                        <tr>
                        <th scope="row">Adresses mémoires</th>
                        <td>L'adresse dans laquelle les données ou les instructions sont stockées. Peut pointer vers la mémoire ou les registres. </td>
                        <td>0xffffffffaa8a25ff, 0x44d0, $rax</td>
                        </tr>
                        <tr>
                        <th scope="row">Les types de donnés</th>
                        <td>Le type de données stockées.</td>
                        <td>byte, word, double word</td>
                        </tr>
                    </tbody>
                </table>
                <br/>
                <h3>Deux types d'instuctions:</h3>
                <br/>
                <p>_Complex Instruction Set Computer (CISC) - Used in Intel and AMD processors in most computers and servers.</p>
                <p>_Reduced Instruction Set Computer (RISC) - Used in ARM and Apple processors, in most smartphones, and some modern laptops.</p>
                <br/>
                <table className="table">
                    <thead>
                        <tr>
                        <th scope="col">Zone</th>
                        <th scope="col">Cisc</th>
                        <th scope="col">Risc</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                        <th scope="row">Complexité</th>
                        <td>Favorise les instructions complexes</td>
                        <td>Favorise les instructions simples</td>
                        </tr>
                        <tr>
                        <th scope="row">Longueur des instuctions</th>
                        <td>Instructions plus longues - Longueur variable 'multiples de 8 bits'</td>
                        <td>Instructions plus courtes - Longueur fixe '32-bit/64-bit'</td>
                        </tr>
                        <tr>
                        <th scope="row">Nombres d'instructions par programmes</th>
                        <td>Moins d'instructions au total - Code plus court</td>
                        <td>Instructions plus totales - Code plus long </td>
                        </tr>
                        <tr>
                        <th scope="row">Optimisation</th>
                        <td>S'appuie sur l'optimisation matérielle (dans le processeur)</td>
                        <td>Repose sur l'optimisation logicielle (en Assembleur)</td>
                        </tr>
                        <tr>
                        <th scope="row">Temps d'execution par instruction</th>
                        <td>Variable - Plusieurs cycles d'horloge</td>
                        <td>Fixé - un cycle d'horloge</td>
                        </tr>
                        <tr>
                        <th scope="row">Nombres d'instuctions supporter par le CPU</th>
                        <td>Beacoup d'instuctions (~1500)</td>
                        <td>Moins d'instructions (~200)</td>
                        </tr>
                        <tr>
                        <th scope="row">Consommation d'energie</th>
                        <td>Haut</td>
                        <td>Très bas</td>
                        </tr>
                        <tr>
                        <th scope="row">Marque de CPU</th>
                        <td>Intel, AMD</td>
                        <td>ARM, Apple</td>
                        </tr>
                    </tbody>
                </table>
                <br/>
                <hr style={{height:"2px", width:"50%", borderWidth:"0", color:"red", backgroundColor:"red"}}/>
                <br/>
                <h1 style={{textAlign: "center"}}>Registres, Adresses, and Types de données:</h1>
                <br/>
                <h2>Les registres</h2>
                <br/>
                <div className='row'>
                    <div className='col'>
                        <h3>Les registres des données:</h3>
                        <p>rax</p>
                        <p>rbx</p>
                        <p>rcx</p>
                        <p>rdx</p>
                        <p>r8</p>
                        <p>r9</p>
                        <p>r10</p>
                    </div>
                    <div className='col'>
                        <h3>Les registres des pointeurs:</h3>
                        <p>rbp (Début de la Stack/Pile)</p>
                        <p>rsp (Emplacement actuel de la Stack/Pile)</p>
                        <p>rip (Adresse de la prochaine instruction)</p>
                    </div>
                </div>
                <br/>
                <br/>
                <table className="table">
                    <thead>
                        <tr>
                        <th scope="col">Description</th>
                        <th scope="col">Registre 64 bits (8 bytes)</th>
                        <th scope="col">Registre 32 bits (4 bytes)</th>
                        <th scope="col">Registre 16 bits (2 bytes)</th>
                        <th scope="col">Registre 8 bits (1 byte)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                        <th scope="row">Numéro d'appel systeme/Valeur de retour</th>
                        <td>rax</td>
                        <td>eax</td>
                        <td>ax</td>
                        <td>al</td>
                        </tr>
                        <tr>
                        <th scope="row">Stockage de données</th>
                        <td>rbx</td>
                        <td>ebx</td>
                        <td>bx</td>
                        <td>bl</td>
                        </tr>
                        <tr>
                        <th scope="row">1er arg</th>
                        <td>rdi</td>
                        <td>edi</td>
                        <td>di</td>
                        <td>dil</td>
                        </tr>
                        <tr>
                        <th scope="row">2ieme arg</th>
                        <td>rsi</td>
                        <td>esi</td>
                        <td>si</td>
                        <td>sil</td>
                        </tr>
                        <tr>
                        <th scope="row">3ieme arg</th>
                        <td>rdx</td>
                        <td>edx</td>
                        <td>dx</td>
                        <td>dl</td>
                        </tr>
                        <tr>
                        <th scope="row">4ieme arg</th>
                        <td>rcx</td>
                        <td>ecx</td>
                        <td>cx</td>
                        <td>cl</td>
                        </tr>
                        <tr>
                        <th scope="row">5ieme arg</th>
                        <td>r8</td>
                        <td>r8d</td>
                        <td>r8w</td>
                        <td>r8b</td>
                        </tr>
                        <tr>
                        <th scope="row">6ieme arg</th>
                        <td>r9</td>
                        <td>r9d</td>
                        <td>r9w</td>
                        <td>r9b</td>
                        </tr>
                        <tr>
                        <th scope="row">Pointeur du début de la Stack</th>
                        <td>rbp</td>
                        <td>ebp</td>
                        <td>bp</td>
                        <td>bpl</td>
                        </tr>
                        <tr>
                        <th scope="row">Pointeur courant de la stack</th>
                        <td>rsp</td>
                        <td>esp</td>
                        <td>sp</td>
                        <td>spl</td>
                        </tr>
                        <tr>
                        <th scope="row">Pointeur de la prochaine instruction</th>
                        <td>rip</td>
                        <td>eip</td>
                        <td>ip</td>
                        <td>ipl</td>
                        </tr>
                        <tr>
                        <th scope="row">Registre lier aux conditions</th>
                        <td>rflags</td>
                        <td>eflags</td>
                        <td>flags</td>
                        <td></td>
                        </tr>
                    </tbody>
                </table>
                <br/>
                <div className='row'>
                    <h2 style={{textAlign: "center"}}>Le registre RFLAGS</h2>
                    <p>Le registre RFLAGS comporte un ensemble de bits qui ont chacun un role et qui sont le resultat de la derniere operation arythmétique (ou une operation mathématique, ou un simple add, ou un cmp)</p>
                </div>
                <br/>
                <table className="table">
                    <thead>
                        <tr>
                        <th scope="col">Bit(s)</th>
                        <th scope="col">0</th>
                        <th scope="col">1</th>
                        <th scope="col">2</th>
                        <th scope="col">3</th>
                        <th scope="col">4</th>
                        <th scope="col">5</th>
                        <th scope="col">6</th>
                        <th scope="col">7</th>
                        <th scope="col">8</th>
                        <th scope="col">9</th>
                        <th scope="col">10</th>
                        <th scope="col">11</th>
                        <th scope="col">12-13</th>
                        <th scope="col">14</th>
                        <th scope="col">15</th>
                        <th scope="col">16</th>
                        <th scope="col">17</th>
                        <th scope="col">18</th>
                        <th scope="col">19</th>
                        <th scope="col">20</th>
                        <th scope="col">21</th>
                        <th scope="col">22-63</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                        <th scope="row">Label (1/0)</th>
                        <td>CF (CY/NC)</td>
                        <td>1</td>
                        <td>PF (PE/PO)</td>
                        <td>0</td>
                        <td>AF (AC/NA)</td>
                        <td>0</td>
                        <td>ZF (ZR/NZ)</td>
                        <td>SF (NC/PL)</td>
                        <td>TF</td>
                        <td>IF (EL/DI)</td>
                        <td>DF (DN/UP)</td>
                        <td>OF (OV/NV)</td>
                        <td>IOPL</td>
                        <td>NT</td>
                        <td>0</td>
                        <td>RF</td>
                        <td>VM</td>
                        <td>AC</td>
                        <td>VIF</td>
                        <td>VIP</td>
                        <td>ID</td>
                        <td>0</td>
                        </tr>
                        <tr>
                        <th scope="row">Description</th>
                        <td>Carry Flag</td>
                        <td>Reserved</td>
                        <td>Parity Flag</td>
                        <td>Reserved</td>
                        <td>Auxiliary Carry Flag</td>
                        <td>Reserved</td>
                        <td>Zero Flag</td>
                        <td>Sign Flag</td>
                        <td>Trap Flag</td>
                        <td>Interrupt Flag</td>
                        <td>Direction Flag</td>
                        <td>Overflow Flag</td>
                        <td>I/O Privilege Level</td>
                        <td>Nested Task</td>
                        <td>Reserved</td>
                        <td>Resume Flag</td>
                        <td>Virtual-x86 Mode</td>
                        <td>Alignment Check / Access Control</td>
                        <td>Virtual Interrupt Flag</td>
                        <td>Virtual Interrupt Pending</td>
                        <td>Identification Flag</td>
                        <td>Reserved</td>
                        </tr>
                    </tbody>
                </table>
                <br/>
                <p>Ceux qui nous interessent le plus sont les suivants:</p>
                <ul>
                    <li>Le Carry Flag CF: Indique si nous avons un float</li>
                    <li>Le Parity Flag PF: Indique si un nombre est pair ou impair</li>
                    <li>Le Zero Flag ZF : Indique si un nombre est égal à zéro</li>
                    <li>Le Sign Flag SF : Indique si un registre est négatif</li>
                </ul>
                <p>Par exemple pour l'instruction <kbd>jnz</kbd>, le jump se fera que si le flag ZF est à 0</p>
                <br/>
                <h2>Les adresses mémoires</h2>
                <br/>
                <table className="table">
                    <thead>
                        <tr>
                        <th scope="col">Mode d'adressage</th>
                        <th scope="col">Description</th>
                        <th scope="col">Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                        <th scope="row">Immédiat</th>
                        <td>La valeur est donnée dans l'instruction</td>
                        <td>add 2</td>
                        </tr>
                        <tr>
                        <th scope="row">Registre</th>
                        <td>Le nom du registre contenant la valeur est donné dans l'instruction</td>
                        <td>add rax</td>
                        </tr>
                        <tr>
                        <th scope="row">Direct</th>
                        <td>L'adresse complète directe est donnée dans l'instruction</td>
                        <td>call 0xffffffffaa8a25ff</td>
                        </tr>
                        <tr>
                        <th scope="row">Indirect</th>
                        <td>Un pointeur de référence est donné dans l'instruction</td>
                        <td>call 0x44d000 ou call [rax]</td>
                        </tr>
                        <tr>
                        <th scope="row">Stack</th>
                        <td>L'adresse est en haut de la Stack/Pile</td>
                        <td>add rbp</td>
                        </tr>
                    </tbody>
                </table>
                <br/>
                <h2>L'indianess</h2>
                <br/>
                <h2>Exemple</h2>
                <br/>
                <table className="table">
                    <thead>
                        <tr>
                        <th scope="col">Adresse</th>
                        <th scope="col">Big indian</th>
                        <th scope="col">Little indian</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                        <th scope="row">0x11223344556677</th>
                        <td>0x7766554433221100</td>
                        <td>0x0011223344556677</td>
                        </tr>
                    </tbody>
                </table>
                <br/>
                <h2>Les types de donnés</h2>
                <br/>
                <table className="table">
                    <thead>
                        <tr>
                        <th scope="col">Composant</th>
                        <th scope="col">Taille</th>
                        <th scope="col">Exemple</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                        <th scope="row">byte</th>
                        <td>8 bits</td>
                        <td>0xab (0b10101011 171)</td>
                        </tr>
                        <tr>
                        <th scope="row">Word</th>
                        <td>16 bits - 2 bytes</td>
                        <td>0xabcd (0b1010101111001101 43981)</td>
                        </tr>
                        <tr>
                        <th scope="row">double word (dword)</th>
                        <td>32 bits - 4 bytes</td>
                        <td>0xabcdef12 (0b10101011110011011110111100010010 2882400018)</td>
                        </tr>
                        <tr>
                        <th scope="row">quad word (qword)</th>
                        <td>64 bits - 8 bytes</td>
                        <td>0xabcdef1234567890 (0b1010101111001101111011110001001000110100010101100111100010010000 12379813812177893520)</td>
                        </tr>
                    </tbody>
                </table>
                <br/>
                <hr style={{height:"2px", width:"50%", borderWidth:"0", color:"red", backgroundColor:"red"}}/>
                <br/>
                <h1 style={{textAlign: "center"}}>La structure du code</h1>
                <br/>
                <div className='row'  style={{textAlign: "center"}}>
                    <div className='col'>
                        <img src={Nasm_structure} alt="Nasm_structure"/>
                    </div>
                </div>
                <br/>
                <table className="table">
                    <thead>
                        <tr>
                        <th scope="col">Section</th>
                        <th scope="col">Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                        <th scope="row">global _start</th>
                        <td>Il s'agit d'une directive qui ordonne au code de commencer à s'exécuter au flag _start définie ci-dessous. </td>
                        </tr>
                        <tr>
                        <th scope="row">section .data</th>
                        <td>Il s'agit de la section des données qui doit contenir toutes les variables initialisées. </td>
                        </tr>
                        <tr>
                        <th scope="row">section .bss</th>
                        <td>Il s'agit de la section des données, qui doit contenir toutes les variables non initialisées. </td>
                        </tr>
                        <tr>
                        <th scope="row">section .text</th>
                        <td>Il s'agit de la section de texte contenant tout le code à exécuter. </td>
                        </tr>
                    </tbody>
                </table>
                <br/>
                <h2>Les variables</h2>
                <br/>
                <table className="table">
                    <thead>
                        <tr>
                        <th scope="col">Instruction</th>
                        <th scope="col">Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                        <th scope="row">db 0x0a</th>
                        <td>Defines the byte 0x0a, which is a new line.</td>
                        </tr>
                        <tr>
                        <th scope="row">message db 0x41, 0x42, 0x43, 0x0a</th>
                        <td>Defines the label message => abc\n.</td>
                        </tr>
                        <tr>
                        <th scope="row">message db "Hello World!", 0x0a</th>
                        <td>Defines the label message => Hello World!\n.</td>
                        </tr>
                    </tbody>
                </table>
                <br/>
                <kbd>Code NASM:</kbd>
                <br/>
                <br/>
                <kbd>
                    section .data<span style={{visibility:"hidden"}}>0</span><br/>
                    <span style={{padding:"0 0 0 40px"}}>message db "Hello World!", 0x0a</span><span style={{visibility:"hidden"}}>0</span><br/>
                    <span style={{padding:"0 0 0 40px"}}>length  equ $-message</span><span style={{visibility:"hidden"}}>0</span><br/>
                </kbd>
                <br/>
                <hr style={{height:"2px", width:"50%", borderWidth:"0", color:"red", backgroundColor:"red"}}/>
                <br/>
                <h1 style={{textAlign: "center"}}>Assemblage et desassemblage</h1>
                <br/>
                <h2>Assembler un fichier:</h2>
                <br/>
                <kbd>
                    En 32 bits:<span style={{visibility:"hidden"}}>0</span><br/>
                    nasm -f elf helloWorld.s<span style={{visibility:"hidden"}}>0</span><br/>
                    En 64 bits<span style={{visibility:"hidden"}}>0</span><br/>
                    nasm -f elf64 helloWorld.s<span style={{visibility:"hidden"}}>0</span><br/>
                </kbd>
                <br/>
                <p>Cela nous permettra de creer un .o</p>
                <br/>
                <h2>Lier un .o:</h2>
                <br/>
                <kbd>
                    En 32 bits:<span style={{visibility:"hidden"}}>0</span><br/>
                    ld -o helloWorld helloWorld.s -m elf_i386<span style={{visibility:"hidden"}}>0</span><br/>
                    En 64 bits<span style={{visibility:"hidden"}}>0</span><br/>
                    ld -o helloWorld helloWorld.s<span style={{visibility:"hidden"}}>0</span><br/>
                </kbd>
                <br/>
                <p>Cela nous permet de creer un binaire à partir d'un .o :)</p>
                <br/>
                <p>Voici un script qui fait le café:</p>
                <kbd>
                    #!/bin/bash<span style={{visibility:"hidden"}}>0</span><br/>
                    fileName='$&#123;1%%.*&#125;'' # remove .s extension<span style={{visibility:"hidden"}}>0</span><br/>
                    <br/>
                    nasm -f elf64 $&#123;fileName&#125;".s"<span style={{visibility:"hidden"}}>0</span><br/>
                    ld $&#123;fileName&#125;".o" -o $&#123;fileName&#125;<span style={{visibility:"hidden"}}>0</span><br/>
                    [ "$2" == "-g" ] && gdb -q $&#123;fileName&#125; || ./$&#123;fileName&#125;<span style={{visibility:"hidden"}}>0</span><br/>
                </kbd>
                <h3>Utilisation:</h3>
                <kbd>
                    ./assembler.sh helloWorld.s<span style={{visibility:"hidden"}}>0</span><br/>
                    ./assembler.sh helloWorld.s -g<span style={{visibility:"hidden"}}>0</span><br/>
                </kbd>
                <br/>
                <h2>Desassembler un binaire:</h2>
                <br/>
                <kbd>
                    en mode verbeux (avec le shellcode):<span style={{visibility:"hidden"}}>0</span><br/>
                    objdump -M intel -d helloWorld<span style={{visibility:"hidden"}}>0</span><br/>
                    en mode non verbeux:<span style={{visibility:"hidden"}}>0</span><br/>
                    objdump -M intel --no-show-raw-insn --no-addresses -d helloWorld<span style={{visibility:"hidden"}}>0</span><br/>
                    Voir les variables et leurs contenu:<span style={{visibility:"hidden"}}>0</span><br/>
                    objdump -sj .data helloWorld<span style={{visibility:"hidden"}}>0</span><br/>
                </kbd>
                <br/>
                <hr style={{height:"2px", width:"50%", borderWidth:"0", color:"red", backgroundColor:"red"}}/>
                <br/>
                <h1 style={{textAlign: "center"}}>GDB</h1>
                <br/>
                <h2>Installation et plugins</h2>
                <kbd>
                    sudo apt-get update<span style={{visibility:"hidden"}}>0</span><br/>
                    sudo apt-get install gdb<span style={{visibility:"hidden"}}>0</span><br/>
                    wget -O ~/.gdbinit-gef.py -q https://github.com/hugsy/gef/raw/master/gef.py<span style={{visibility:"hidden"}}>0</span><br/>
                    echo source ~/.gdbinit-gef.py >> ~/.gdbinit<span style={{visibility:"hidden"}}>0</span><br/>
                </kbd>
                <p>Documentation <a href='https://gef.readthedocs.io/en/master/'>GEF</a></p>
                <br/>
                <h2>Examiner la mémoire</h2>
                <br/>
                <table className="table">
                    <thead>
                        <tr>
                        <th scope="col">Argument</th>
                        <th scope="col">Description</th>
                        <th scope="col">Exemple</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                        <th scope="row">Compteur</th>
                        <td>Le nombre de fois que nous voulons répéter l'examination.</td>
                        <td>2, 3, 10</td>
                        </tr>
                        <tr>
                        <th scope="row">Format</th>
                        <td>Le format dans lequel nous voulons afficher le resultat</td>
                        <td>x(hex), s(string), i(instruction)</td>
                        </tr>
                        <tr>
                        <th scope="row">Taille</th>
                        <td>La taille de la mémoire que nous voulons examiner</td>
                        <td>b(byte), h(halfword), w(word), g(giant, 8 bytes)</td>
                        </tr>
                    </tbody>
                </table>
                <br/>
                <h3>Example:</h3>
                <br/>
                <p>Instruction:</p>
                <kbd>
                    gef➤  x/4ig $rip<span style={{visibility:"hidden"}}>0</span><br/>
                    => 0x401000 &#60;_start&#62;:	mov    eax,0x1<span style={{visibility:"hidden"}}>0</span><br/>
                    0x401005 &#60;_start+5&#62;:	mov    edi,0x1<span style={{visibility:"hidden"}}>0</span><br/>
                    0x40100a &#60;_start+10&#62;:	movabs rsi,0x402000<span style={{visibility:"hidden"}}>0</span><br/>
                    0x401014 &#60;_start+20&#62;:	mov    edx,0x12<span style={{visibility:"hidden"}}>0</span><br/>
                </kbd>
                <br/>
                <p>Strings:</p>
                <kbd>
                    gef➤  x/s 0x402000<span style={{visibility:"hidden"}}>0</span><br/>
                    0x402000:	"Hello HTB Academy!"<span style={{visibility:"hidden"}}>0</span><br/>
                </kbd>
                <br/>
                <p>Adresses:</p>
                <kbd>
                    gef➤  x/wx 0x401000<span style={{visibility:"hidden"}}>0</span><br/>
                    0x401000 &#60;_start&#62;:	0x000001b8<span style={{visibility:"hidden"}}>0</span><br/>
                </kbd>
                <p>
                    "0x000001b8" represente le code machine au format little indian de l'instruction "<kbd>mov eax,0x1</kbd>", soit "b8 01 00 00" au format big indian
                </p>
                <br/>
                <p>Un autre exemple que je n ai pas trop compris, mais qui converti une valeur hexa en decimale:</p>
                <kbd>
                    p/d $rbx<span style={{visibility:"hidden"}}>0</span><br/>
                </kbd>
                <br/>
                <h2>Lire les parametres du main</h2>
                <p>Pour commencer, il faut break a *main+0</p>
                <p>Pour recuperer le nombre parametres du main, il faut examiner $esp+4: <kbd>(gdb) x/xw $esp+4</kbd></p>
                <p>Pour recuperer les adresses des parametres du main, il faut examiner $esp+8 recuperer l adresse qui pointe sur la premiere adresse des parametres du main</p>
                <div className='row'  style={{textAlign: "center"}}>
                    <div className='col'>
                        <img src={Parametres_main} alt="Parametres_main" style={{width:"50%", maxWidth:"800px"}}/>
                    </div>
                </div>
                <br/>
                <h2>Modifier la valeur d'une variable</h2>
                <br/>
                <kbd>
                    Breakpoint 1 at 0x401019<span style={{visibility:"hidden"}}>0</span><br/>
                    gef➤  r<span style={{visibility:"hidden"}}>0</span><br/>
                    gef➤  patch string 0x402000 "Patched!\\x0a"<span style={{visibility:"hidden"}}>0</span><br/>
                    gef➤  c<span style={{visibility:"hidden"}}>0</span><br/>
                    Continuing.<span style={{visibility:"hidden"}}>0</span><br/>
                    Patched!<span style={{visibility:"hidden"}}>0</span><br/>
                    Academy!<span style={{visibility:"hidden"}}>0</span><br/>
                </kbd>
                <p>Nous avons modifier la chaine de caractere, mais write affichait une longueur de 12 octets, donc le reste de la string a aussi ete afficher</p>
                <br/>
                <h2>Modifier la valeur d'un registre</h2>
                <br/>
                <kbd>
                    gef➤  break *0x401019<span style={{visibility:"hidden"}}>0</span><br/>
                    Breakpoint 1 at 0x401019<span style={{visibility:"hidden"}}>0</span><br/>
                    gef➤  r<span style={{visibility:"hidden"}}>0</span><br/>
                    gef➤  patch string 0x402000 "Patched!\\x0a"<span style={{visibility:"hidden"}}>0</span><br/>
                    gef➤  set $rdx=0x9<span style={{visibility:"hidden"}}>0</span><br/>
                    gef➤  c<span style={{visibility:"hidden"}}>0</span><br/>
                    Continuing.<span style={{visibility:"hidden"}}>0</span><br/>
                    Patched!<span style={{visibility:"hidden"}}>0</span><br/>
                </kbd>
                <br/>
                <p>Voila, c est patch</p>
                <br/>
                <p>Dans le cas du code si dessous, si nous l executons avec gdb et le framework GEF, nous voyons que GEF utilise le terme <kdb>TAKEN [Reason: S]</kdb>, cela veut dire que la condition du jump (js) est remplie pour son execution et le S represente la condition du jump, soit le BIT de SIGN dans notre cas</p>
                <div className='row'  style={{textAlign: "center"}}>
                    <div className='col'>
                        <img src={Asm_taken} alt="Asm_taken" style={{width:"100%"}}/>
                    </div>
                </div>
                <br/>
                <div className='row'  style={{textAlign: "center"}}>
                    <div className='col'>
                        <img src={Gdb_taken} alt="Gdb_taken" style={{width:"100%"}}/>
                    </div>
                </div>
                <br/>
                <p>Pour afficher toutes les fonction qui se suivent, voici comment faire:</p>
                <div className='row'  style={{textAlign: "center"}}>
                    <div className='col'>
                        <img src={Next_functions} alt="Next_functions" style={{width:"100%"}}/>
                    </div>
                </div>
                <h2>Les break</h2>
                <p>exemples:</p>
                <p>b *loopFib+9</p>
                <p>b loopFib</p>
                <p>b *0x000000000040100f</p>
                <p>b *loopFib+9 if $rbx &#62; 10</p>
                <br/>
                <h2>Les etapes</h2>
                <p><kbd>si</kbd>: Step Instruction, break a la prochaine instruction, meme si elle est dans une autre fonction</p>
                <p><kbd>ni</kbd>: Next Instruction, break a la prochaine instruction de cette fonction</p>
                <h2>Les calculs</h2>
                <p><kbd>p/d 0xffffffff - 0x87097876</kbd> Fait le calcul et affiche le resultat en decimal</p>
                <p><kbd>p/x 0xffffffff - 0x87097876</kbd> Fait le calcul et affiche le resultat en hexadecimal</p>
                <br/>
                <hr style={{height:"2px", width:"50%", borderWidth:"0", color:"red", backgroundColor:"red"}}/>
                <br/>
                <h1 style={{textAlign: "center"}}>Les mouvements de données</h1>
                <br/>
                <h2>Les instructions générales:</h2>
                <br/>
                <table className="table">
                    <thead>
                        <tr>
                        <th scope="col">Instruction</th>
                        <th scope="col">Description</th>
                        <th scope="col">Exemple</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                        <th scope="row">mov</th>
                        <td>Déplacer des données ou charger des données immédiates </td>
                        <td>mov rax, 1 -> rax = 1</td>
                        </tr>
                        <tr>
                        <th scope="row">lea</th>
                        <td>Charger une adresse pointant vers la valeur </td>
                        <td>lea rax, [rsp+5] -> rax = rsp+5 </td>
                        </tr>
                        <tr>
                        <th scope="row">xchg</th>
                        <td>Échange de données entre deux registres ou adresses </td>
                        <td>xchg rax, rbx -> rax = rbx, rbx = rax</td>
                        </tr>
                        <tr>
                        <th scope="row">cmp</th>
                        <td>Définit RFLAGS en soustrayant destination - source, la destination doit être un registre, tandis que l'autre peut être un registre, une variable ou une valeur immédiate (dans nos deux exemples, nous comparons bien les valeurs !)</td>
                        <td>
                            cmp rax, rbx -> rax - rbx<br/>
                            cmp rbx,[var] -> rbx - var
                        </td>
                        </tr>
                    </tbody>
                </table>
                <br/>
                <h2>Details des instructions:</h2>
                <br/>
                <table className="table">
                    <thead>
                        <tr>
                        <th scope="col">Instruction</th>
                        <th scope="col">Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                        <th scope="row">mov rax, rbx</th>
                        <td>Copie l adresse de la valeur finale de rbx dans rax</td>
                        </tr>
                        <tr>
                        <th scope="row">mov rax, [rbx]</th>
                        <td>Copie la valeur de rbx dans rax</td>
                        </tr>
                        <tr>
                        <th scope="row">mov rax, [rbx + 5]</th>
                        <td>Copie la valeur de rbx + 5 adresses dans rax</td>
                        </tr>
                        <tr>
                        <th scope="row">mov rax, QWORD PTR [rbx]</th>
                        <td>Copie la valeur de rbx (d'une taille de 64 bits en precisant que la valeur va etre chercher dans un pointeur) dans rax</td>
                        </tr>
                        <tr>
                        <th scope="row">lea rax, [rsp] (equivalent a: mov rax, rsp)</th>
                        <td>Copie l'adresse du pointeur de rsp dans rax</td>
                        </tr>
                        <tr>
                        <th scope="row">lea rax, [rsp+10] (impossible de faire pareil avec mov)</th>
                        <td>Copie l'adresse du pointeur de rsp+10 dans rax</td>
                        </tr>
                        <tr>
                        <th scope="row">mov [r12], rsp</th>
                        <td>Copie rsp dans l'adresse finale de r12 (en partant du principe que r12 est un pointeur)</td>
                        </tr>
                    </tbody>
                </table>
                <br/>
                <h2>Afficher l'adresse d'EIP et de sace EIP:</h2>
                <br/>
                <div className='row'  style={{textAlign: "center"}}>
                    <div className='col'>
                        <img src={Get_saved_eip} alt="Get_saved_eip"/>
                    </div>
                </div>
                <br/>
                <h2>Exercice:</h2>
                <br/>
                <p>Ajoutez une instruction à la fin du code joint pour déplacer la valeur de "rsp" vers "rax". Quelle est la valeur hexadécimale de "rax" à la fin de l'exécution du programme ? </p>
                <br/>
                <kbd>
                    global _start<span style={{visibility:"hidden"}}>0</span><br/>
                    section .text<span style={{visibility:"hidden"}}>0</span><br/>
                    _start:<span style={{visibility:"hidden"}}>0</span><br/>
                        <span style={{padding:"0 0 0 40px"}}>mov rax, 1024</span><span style={{visibility:"hidden"}}>0</span><br/>
                        <span style={{padding:"0 0 0 40px"}}>mov rbx, 2048</span><span style={{visibility:"hidden"}}>0</span><br/>
                        <span style={{padding:"0 0 0 40px"}}>xchg rax, rbx</span><span style={{visibility:"hidden"}}>0</span><br/>
                        <span style={{padding:"0 0 0 40px"}}>push rbx</span><span style={{visibility:"hidden"}}>0</span><br/>
                </kbd>
                <br/>
                <p>Voici le code une fois l instruction rajouter:</p>
                <br/>
                <kbd>
                    global _start<span style={{visibility:"hidden"}}>0</span><br/>
                    section .text<span style={{visibility:"hidden"}}>0</span><br/>
                    _start:<span style={{visibility:"hidden"}}>0</span><br/>
                        <span style={{padding:"0 0 0 40px"}}>mov rax, 1024</span><span style={{visibility:"hidden"}}>0</span><br/>
                        <span style={{padding:"0 0 0 40px"}}>mov rbx, 2048</span><span style={{visibility:"hidden"}}>0</span><br/>
                        <span style={{padding:"0 0 0 40px"}}>xchg rax, rbx</span><span style={{visibility:"hidden"}}>0</span><br/>
                        <span style={{padding:"0 0 0 40px"}}>push rbx</span><span style={{visibility:"hidden"}}>0</span><br/>
                        <span style={{padding:"0 0 0 40px"}}>mov rax, [rsp]</span><span style={{visibility:"hidden"}}>0</span><br/>
                </kbd>
                <br/>
                <p>La valeur de rax à la fin est de 0x400, soit 1024</p>
                <br/>
                <h2>Les operations sur les strings</h2>
                <table className="table">
                    <thead>
                        <tr>
                        <th scope="col">Operation</th>
                        <th scope="col">Explication</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                        <th scope="row">repz cmps BYTE PTR ds:[esi],BYTE PTR es:[edi]</th>
                        <td>
                            repz: Parcoure la chaine tant que certains flags ne sont pas la  [A FINIR]<br/>
                            cmps: Compare les donnees suivantes<br/>
                            BYTE: bytes par bytes<br/>
                            PTR: Je ne sais pas
                        </td>
                        </tr>
                        <tr>
                        <th scope="row">repnz scas al,BYTE PTR es:[edi]</th>
                        <td>
                            repnz: Parcoure la chaine tant que certains flags ne sont pas la  [A FINIR]<br/>
                            scas:
                            BYTE: bytes par bytes<br/>
                            PTR: Je ne sais pas
                        </td>
                        </tr>
                        <tr>
                        <th scope="row">movsx eax,al</th>
                        <td></td>
                        </tr>
                    </tbody>
                </table>
                <br/>
                <h2>Des instructions a connaitre</h2>
                <table className="table">
                    <thead>
                        <tr>
                        <th scope="col">Asm</th>
                        <th scope="col">C</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                        <th scope="row">seta dl</th>
                        <td>dl = (edx &#62; 0) ? 1 : 0;</td>
                        </tr>
                        <tr>
                        <th scope="row">setb al</th>
                        <td>al = (eax &#60; 0) ? 1 : 0;</td>
                        </tr>
                        <tr>
                        <th scope="row">test eax,edx</th>
                        <td>
                            TEMP = eax & edx<br/>
                            SI TEMP = 0 ALORS<br/>
                                ZF ← 1<br/>
                            SINON<br/>
                                ZF ← 0<br/>
                            FIN SI
                        </td>
                        </tr>
                        <tr>
                        <th scope="row">test eax,eax</th>
                        <td>
                            equivalent a: cmp eax, 0
                        </td>
                        </tr>
                    </tbody>
                </table>
                <br/>
                <hr style={{height:"2px", width:"50%", borderWidth:"0", color:"red", backgroundColor:"red"}}/>
                <br/>
                <h1 style={{textAlign: "center"}}>Les instructions arithmétiques</h1>
                <br/>
                <h2>Les instructions unaires:</h2>
                <br/>
                <table className="table">
                    <thead>
                        <tr>
                        <th scope="col">Instruction</th>
                        <th scope="col">Description</th>
                        <th scope="col">Exemple</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                        <th scope="row">inc</th>
                        <td>Incrémentation de rax de 1</td>
                        <td>inc rax -> rax++ or rax += 1</td>
                        </tr>
                        <tr>
                        <th scope="row">dec</th>
                        <td>Décrémentation de rax de 1</td>
                        <td>dec rax -> rax-- or rax -= 1 -> rax = 0</td>
                        </tr>
                    </tbody>
                </table>
                <br/>
                <h2>Les instructions binaires:</h2>
                <br/>
                <table className="table">
                    <thead>
                        <tr>
                        <th scope="col">Instruction</th>
                        <th scope="col">Description</th>
                        <th scope="col">Exemple</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                        <th scope="row">add</th>
                        <td>Additionne deux operandes</td>
                        <td>add rax, rbx et stock le resultat dans le premier argument</td>
                        </tr>
                        <tr>
                        <th scope="row">sub</th>
                        <td>Soustrais la source de la destination (rax = rax - rbx) et stock le resultat dans le premier argument</td>
                        <td>sub rax, rbx</td>
                        </tr>
                        <tr>
                        <th scope="row">imul</th>
                        <td>Multipli les deux operandes et stock le resultat dans le premier argument</td>
                        <td>imul rax, rbx</td>
                        </tr>
                    </tbody>
                </table>
                <br/>
                <h2>Les instructions sur les bits (Bitwise):</h2>
                <br/>
                <p>Pour le tableau suivant: rax = 1 et rbx = 2</p>
                <br/>
                <table className="table">
                    <thead>
                        <tr>
                        <th scope="col">Instruction</th>
                        <th scope="col">Description</th>
                        <th scope="col">Exemple</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                        <th scope="row">not</th>
                        <td>Bitwise NOT (Inverse les bits)</td>
                        <td>not rax -> NOT 00000001 -> 11111110</td>
                        </tr>
                        <tr>
                        <th scope="row">and</th>
                        <td>Bitwise AND (si les deux bits que l'on compare sont a 1 -> 1, sinon -> 0)</td>
                        <td>and rax, rbx -> 00000001 AND 00000010 -> 00000000</td>
                        </tr>
                        <tr>
                        <th scope="row">or</th>
                        <td>Bitwise OR (Si l'un des bits vaut 1 -> 1, sinon -> 0)</td>
                        <td>or rax, rbx -> 00000001 OR 00000010 -> 00000011</td>
                        </tr>
                        <tr>
                        <th scope="row">xor</th>
                        <td>Bitwise XOR (Si les bits sont les differents -> 1, sinon -> 0)</td>
                        <td>xor rax, rbx -> 00000001 XOR 00000010 -> 00000011</td>
                        </tr>
                    </tbody>
                </table>
                <br/>
                <div className='row'  style={{textAlign: "center"}}>
                    <div className='col'>
                        <img src={Bitwise} alt="Bitwise"/>
                    </div>
                </div>
                <br/>
                <hr style={{height:"2px", width:"50%", borderWidth:"0", color:"red", backgroundColor:"red"}}/>
                <br/>
                <h1 style={{textAlign: "center"}}>Les boucles</h1>
                <br/>
                <h2>La structure loop:</h2>
                <br/>
                <table className="table">
                    <thead>
                        <tr>
                        <th scope="col">Instruction</th>
                        <th scope="col">Description</th>
                        <th scope="col">Exemple</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                        <th scope="row">mov rcx, x</th>
                        <td>Initialise le compteur de boucle (rcx)</td>
                        <td>mov rcx, 3</td>
                        </tr>
                        <tr>
                        <th scope="row">loop</th>
                        <td>Jump au debut de la boucle tant que rcx ne vaut pas zero et decrement rcx de 1</td>
                        <td>loop exampleLoop</td>
                        </tr>
                    </tbody>
                </table>
                <br/>
                <hr style={{height:"2px", width:"50%", borderWidth:"0", color:"red", backgroundColor:"red"}}/>
                <br/>
                <h1 style={{textAlign: "center"}}>Les branches (jump...) et les conditions</h1>
                <br/>
                <table className="table">
                    <thead>
                        <tr>
                        <th scope="col">Instruction</th>
                        <th scope="col">Condition</th>
                        <th scope="col">Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                        <th scope="row">jmp</th>
                        <td>Aucune</td>
                        <td>Jumps a un endroit preçis, comme un label, une adresse ou à un endroit spécifié(Le dernier, j ai pas tout compris...)</td>
                        </tr>
                        <tr>
                        <th scope="row">jz</th>
                        <td>D == 0</td>
                        <td>Destination equal to Zero</td>
                        </tr>
                        <tr>
                        <th scope="row">jnz</th>
                        <td>D != 0</td>
                        <td>Destination Not equal to Zero</td>
                        </tr>
                        <tr>
                        <th scope="row">js</th>
                        <td>D &#60; 0</td>
                        <td>Destination is Negative</td>
                        </tr>
                        <tr>
                        <th scope="row">jns</th>
                        <td>D &#62;= 0</td>
                        <td>Destination is Not Negative</td>
                        </tr>
                        <tr>
                        <th scope="row">jg</th>
                        <td>D &#62; S</td>
                        <td>Destination Greater than Source</td>
                        </tr>
                        <tr>
                        <th scope="row">jge</th>
                        <td>D &#62;= S</td>
                        <td>Destination Greater than or Equal Source</td>
                        </tr>
                        <tr>
                        <th scope="row">jl</th>
                        <td>D &#60; S</td>
                        <td>Destination Less than Source</td>
                        </tr>
                        <tr>
                        <th scope="row">jle</th>
                        <td>D &#60;= S</td>
                        <td>Destination Less than or Equal Source</td>
                        </tr>
                        <tr>
                        <th scope="row">cmovl</th>
                        <td>D &#60; S</td>
                        <td>Condition Moove Lower</td>
                        </tr>
                    </tbody>
                </table>
                <br/>
                <p>Une liste complete de tout les jumps <a href='https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf#page=585'>ici</a></p>
                <br/>
                <hr style={{height:"2px", width:"50%", borderWidth:"0", color:"red", backgroundColor:"red"}}/>
                <br/>
                <h1 style={{textAlign: "center"}}>L'instruction call</h1>
                <br/>
                <table className="table">
                    <thead>
                        <tr>
                        <th scope="col">Instruction</th>
                        <th scope="col">exemple</th>
                        <th scope="col">Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                        <th scope="row">call</th>
                        <td>call count_len</td>
                        <td>call le label ou la fonction count_len en pushant $eip sur la stack</td>
                        </tr>
                        <tr>
                        <th scope="row">ret</th>
                        <td>ret</td>
                        <td>retabli $eip ou l adresse est actuellement sur la stack, c est l equivalent de <kbd>pop eip</kbd> en gros</td>
                        </tr>
                        <tr>
                        <th scope="row">jmp</th>
                        <td>jmp count_len</td>
                        <td>Jumps au label count_len sans rien modifié</td>
                        </tr>
                    </tbody>
                </table>
                <br/>
                <p>L'instruction call permet d'appeler une fonction ou un label, a la difference de jump, call push $eip sur la stack et pop $eip quand l'instruction ret est appeler dans cette fonction/label</p>
                <br/>
                <hr style={{height:"2px", width:"50%", borderWidth:"0", color:"red", backgroundColor:"red"}}/>
                <br/>
                <h1 style={{textAlign: "center"}}>La Stack/Pile</h1>
                <br/>
                <table className="table">
                    <thead>
                        <tr>
                        <th scope="col">Instruction</th>
                        <th scope="col">Description</th>
                        <th scope="col">Exemple</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                        <th scope="row">push</th>
                        <td>Copie le registre/l'adresse spécifié(e) en haut de la pile</td>
                        <td>push rax</td>
                        </tr>
                        <tr>
                        <th scope="row">pop</th>
                        <td>Déplace l'élément en haut de la pile vers le registre/l'adresse spécifié(e)</td>
                        <td>pop rax</td>
                        </tr>
                    </tbody>
                </table>
                <br/>
                <hr style={{height:"2px", width:"50%", borderWidth:"0", color:"red", backgroundColor:"red"}}/>
                <br/>
                <h1 style={{textAlign: "center"}}>Les appels systemes/ Syscalls</h1>
                <br/>
                <p>
                    Un <a href='https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64'>lien</a> qui les ressencent avec les OPCODE (syscall number)<br/>
                    Un autre <a href='https://chromium.googlesource.com/chromiumos/docs/+/HEAD/constants/syscalls.md#x86-32_bit'>lien</a> qui les ressences aussi pour les achitectures arm, 32bits et 64 bits
                </p>
                <h2>Les arguments:</h2>
                <br/>
                <table className="table">
                    <thead>
                        <tr>
                        <th scope="col">Description</th>
                        <th scope="col">Registre 64 bits</th>
                        <th scope="col">Registre 32 bits</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                        <th scope="row">Syscall Number/Return value</th>
                        <td>rax</td>
                        <td>al</td>
                        </tr>
                        <tr>
                        <th scope="row">??Callee Saved??</th>
                        <td>rbx</td>
                        <td>bl</td>
                        </tr>
                        <tr>
                        <th scope="row">1st arg</th>
                        <td>rdi</td>
                        <td>dil</td>
                        </tr>
                        <tr>
                        <th scope="row">2th arg</th>
                        <td>rsi</td>
                        <td>sil</td>
                        </tr>
                        <tr>
                        <th scope="row">3th arg</th>
                        <td>rdx</td>
                        <td>cl</td>
                        </tr>
                        <tr>
                        <th scope="row">4th arg</th>
                        <td>rcx</td>
                        <td>bpl</td>
                        </tr>
                        <tr>
                        <th scope="row">5th arg</th>
                        <td>r8</td>
                        <td>r8b</td>
                        </tr>
                        <tr>
                        <th scope="row">6th arg</th>
                        <td>r9</td>
                        <td>r9b</td>
                        </tr>
                        <tr>
                        <th scope="row">next args</th>
                        <td>On the stack !</td>
                        <td></td>
                        </tr>
                    </tbody>
                </table>
                <br/>
                <p>On peut trouver un appel systeme sans internet comme suit:</p>
                <kbd>grep exit /usr/include/x86_64-linux-gnu/asm/unistd_64.h<br/></kbd>
                <br/>
                <h2>L'instruction ret:</h2>
                <p>L'instruction ret joue un rôle essentiel dans la programmation orientée retour (ROP), une technique d'exploitation généralement utilisée avec l'exploitation binaire.</p>
                <br/>
                <table className="table">
                    <thead>
                        <tr>
                        <th scope="col">Instruction</th>
                        <th scope="col">Description</th>
                        <th scope="col">Exemple</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                        <th scope="row">call</th>
                        <td>pousse le pointeur d'instruction suivant (RIP) vers la pile, puis passe à la procédure spécifiée</td>
                        <td>call printMessage</td>
                        </tr>
                        <tr>
                        <th scope="row">ret</th>
                        <td>pop l'adresse à rsp dans rip, puis sautez dessus</td>
                        <td>ret</td>
                        </tr>
                    </tbody>
                </table>
                <br/>
                <h2>/!\ L'alignement de la stack /!\</h2>
                <p>Avant d'appeler une fonction, il faut aligner la stack sur un multiple de 16 bits</p>
                <p>Afin de savoir sur combien de bits la stack est aligner actuellement, il faut compter le nombre de push et de call, chacun compte 8 bits</p>
                <p>La technique pour aligner la stack est la suivante:</p>
                <br/>
                <div className='row'  style={{textAlign: "center"}}>
                    <div className='col'>
                        <img src={Stack_alignment} alt="Stack_alignment"/>
                    </div>
                </div>
                <br/>
                <h2>Les etapes avant l'appel d'une fonction:</h2>
                <kbd>
                    Save Registers on the Stack (Caller Saved)<br/>
                    Pass Function Arguments (like syscalls)<br/>
                    Fix Stack Alignment<br/>
                    Get Functions' Return Value (in rax)<br/>
                </kbd>
                <br/>
                <hr style={{height:"2px", width:"50%", borderWidth:"0", color:"red", backgroundColor:"red"}}/>
                <br/>
                <h1 style={{textAlign: "center"}}>Les arguments</h1>
                <br/>
                <p>Le nombre d'argument et les arguments d'un binaire peuvent etre recuperer au debut de la stack au lancement du binaire, voici un <a href='https://github.com/guyb27/asm_tutor/blob/main/helloWorld_arguments.s'>exemple</a></p>
                <br/>
                <hr style={{height:"2px", width:"50%", borderWidth:"0", color:"red", backgroundColor:"red"}}/>
                <br/>
                <h1 style={{textAlign: "center"}}>Les Shellcodes</h1>
                <br/>
                <p>Afin d'assembler du code en shellcode ou de desassembler un shellcode en code, nous allons utiliser les binaires du package <kbd>pwntools</kbd></p>
                <h2>Installation:</h2>
                <p><kbd>sudo pip3 install pwntools</kbd></p>
                <h2>Utilisation:</h2>
                <p>Pour assembler du code en shellcode:</p>
                <br/>
                <div className='row'  style={{textAlign: "center"}}>
                    <div className='col'>
                        <img src={Code_to_shellcode} alt="code_to_shellcode"/>
                    </div>
                </div>
                <br/>
                <p>Pour desassembler un shellcode en code:</p>
                <br/>
                <div className='row'  style={{textAlign: "center"}}>
                    <div className='col'>
                        <img src={Shellcode_to_code} alt="shellcode_to_code"/>
                    </div>
                </div>
                <br/>
                <p>Plus d'information <a href='https://docs.pwntools.com/en/stable/commandline.html'>ici</a> (shell) et <a href='https://docs.pwntools.com/en/stable/asm.html'>ici</a> (python)</p>
                <h2>Exemple:</h2>
                <p>Voici un exemple de shellcode que nous allons executer:</p>
                <br/>
                <div className='row'  style={{textAlign: "center"}}>
                    <div className='col'>
                        <img src={Exec_shellcode} alt="Exec_shellcode"/>
                    </div>
                </div>
                <br/>
                <p>Pour construire un fichier elf a partir d un shellcode, voici comment proceder:</p>
                <br/>
                <div className='row'  style={{textAlign: "center"}}>
                    <div className='col'>
                        <img src={Shellcode_to_elf} alt="Shellcode_to_elf"/>
                    </div>
                </div>
                <br/>
                <h2>Les regles du shellcode:</h2>
                <p>Pour construire un shellcode, nous devons respecter ces trois règles:</p>
                <ul>
                    <li>Il ne doit pas avoir de variables</li>
                    <li>Ne fait pas référence aux adresses mémoire directes</li>
                    <li>Ne contient aucun octet NULL 00 ni de bad char (\x00\x09\x0a\x20)</li>
                </ul>
                <h2>Creer une chaine de caractere:</h2>
                <p>Afin de creer une chaine de caractere, nous devons pousser directement des char* de maximum /!\4 octets/!\ dans une variable, puis ensuite les push sur la stack comme ceci:</p>
                <br/>
                <div className='row'  style={{textAlign: "center"}}>
                    <div className='col'>
                        <img src={Shellcode_array} alt="Shellcode_array"/>
                    </div>
                </div>
                <br/>
                <p>Nous n avons pas besoin d'envoyer 00 ('\0') sur la stack avant notre chaine, car nous allons specifier sa taille</p>
                <p>Au moment ou nous copions $rsp dans $rsi notre char* est complete en haut de la stack, il n y a juste pas de '\0', mais ce n est pas grave, car nous utiliserons write avec un taille pour afficher</p>
                <p>Pour mettre un '\0' a la fin de notre chaine de caractere, nous pouvons contourner le probleme du NULL byte comme suit:</p>
                <kbd>
                    xor rbx, rbx;<br/>
                    push rbx;<br/>
                    mov rbx, 'y!';<br/>
                    push rbx;<br/>
                    mov rbx, 'B Academ';<br/>
                    push rbx;<br/>
                    mov rbx, 'Hello HT';<br/>
                    push rbx;<br/>
                    mov rsi, rsp<br/>
                </kbd>
                <h2>Voici deux exemples de code pret pour etre converti en shellcode:</h2>
                <br/>
                <div className='row'  style={{textAlign: "center"}}>
                    <div className='col'>
                        <img src={Shellcode_exemple_code} alt="Shellcode_exemple_code"/>
                    </div>
                </div>
                <br/>
                <div className='row'  style={{textAlign: "center"}}>
                    <div className='col'>
                        <img src={Shellcode_requirement} alt="Shellcode_requirement"/>
                    </div>
                </div>
                <h2>Pwntools Shellcraft</h2>
                <p>pwn avec l'argument shellcraft permet la creation et l execution de shellcode, nous pouvons voir la liste complete de shellcode grace a la commande:</p>
                <p><kbd>pwn shellcraft -l</kbd></p>
                <p>Les deux lignes suivantes vont nous permettre de mieux cibler nos cibles:</p>
                <p><kbd>pwn shellcraft -l 'i386.linux'</kbd></p>
                <p><kbd>pwn shellcraft -l 'amd64.linux'</kbd></p>
                <p>Voici comment voir le shellcode d' une commande:</p>
                <p><kbd>pwn shellcraft amd64.linux.sh</kbd></p>
                <p>Et voici comment l'executer directement:</p>
                <p><kbd>pwn shellcraft amd64.linux.sh -r</kbd></p>
                <p>Il existe aussi un module en python pour creer des shellcode, voici la <a href='https://docs.pwntools.com/en/stable/shellcraft/amd64.html'>doc</a></p>
                <p>N'oubliez pas les lignes suivantes:</p>
                <p><kbd>from pwn import *</kbd></p>
                <p><kbd>context(os="linux", arch="amd64", log_level="error")</kbd></p>
                <br/>
                <h2>MSF Venom</h2>
                <p>MSF venom permet aussi la creation et l execution de shellcode, nous pouvons voir la liste complete de shellcode grace a la commande:</p>
                <p><kbd>msfvenom -l payloads</kbd></p>
                <p>Les deux lignes suivantes vont nous permettre de mieux cibler nos cibles:</p>
                <p><kbd>msfvenom -l payloads | grep 'linux/x64'</kbd></p>
                <p><kbd>msfvenom -l payloads | grep 'linux/x86''</kbd></p>
                <p>Voici l'exemple d une commande pour executer un shell:</p>
                <p><kbd>msfvenom -p 'linux/x64/exec' CMD='sh' -a 'x64' --platform 'linux' -f 'hex' -b '\x00\x09\x0a\x20'</kbd></p>
                <p>Noter que ce shellcode n est pas optimiser</p>
                <br/>
                <h2>L'encodage des shellcodes</h2>
                <p>Dans notre cas cas, nous allons utiliser msfvenom pour encoder nos shellcodes, meme si cet encodeur est connus et facile a detecter</p>
                <p>Nous pouvons voir la liste des encodeurs comms suit:</p>
                <p><kbd>msfvenom -l encoders</kbd></p>
                <p>Nous pouvons encoder un shellcode generer avec msfvenom comme suit:</p>
                <p><kbd>msfvenom -p 'linux/x64/exec' CMD='sh' -a 'x64' --platform 'linux' -f 'hex' -e 'x64/xor' -b '\x00\x09\x0a\x20'</kbd></p>
                <p>Nous pouvons l'encoder 8 fois ou plus avec l'option 'i' comme suit:</p>
                <p><kbd>msfvenom -p 'linux/x64/exec' CMD='sh' -a 'x64' --platform 'linux' -f 'hex' -e 'x64/xor' -i 8 -b '\x00\x09\x0a\x20'</kbd></p>
                <p>Nous pouvons aussi encoder notre propre code omme suit:</p>
                <p><kbd>python3 -c "import sys; sys.stdout.buffer.write(bytes.fromhex('4831c0b03b6a0048bf2f62696e2f2f7368574889e76a00574889e64831d2b2000f05'))" &#62; shell.bin</kbd></p>
                <p><kbd>msfvenom -p - -a 'x64' --platform 'linux' -f 'hex' -e 'x64/xor' &#60; shell.bin</kbd></p>
                <p>Et comme d'habitude, nous l executons comme suit:</p>
                <p><kbd>python3 loader.py '4831c94881e9faffffff488d05efffffff48bbf377c2ea294e325c48315827482df8ffffffe2f4994c9a7361f51d3e9a19ed99414e61147a90aac74a4e32147a9190022a4e325c801fc2bc7e06bbbafc72c2ea294e325c'</kbd></p>
                <p>Enfin, nous pouvons toujours rechercher des ressources en ligne comme <a href='http://shell-storm.org/shellcode/'>Shell-Storm</a> ou <a href='https://www.exploit-db.com/shellcodes'>Exploit DB</a> pour les shellcodes existants.</p>
                <p>Par exemple, si nous cherchons dans Shell-Storm un shellcode /bin/sh sous Linux/x86_64, nous trouverons plusieurs exemples de tailles variables, comme ce <a href='http://shell-storm.org/shellcode/files/shellcode-806.php'>shellcode de 27 octets</a>. Nous pouvons rechercher la même chose dans Exploit DB et nous trouvons un <a href='https://www.exploit-db.com/shellcodes/47008'>shellcode de 22 octets</a> plus optimisé, ce qui peut être utile si notre exploitation binaire ne disposait que d'environ 22 octets d'espace de débordement. Nous pouvons également rechercher des shellcodes encodés, qui sont forcément plus volumineux.</p>
                <p>Le shellcode que nous avons écrit ci-dessus fait également 34 octets, il semble donc être un shellcode très optimisé. Avec tout cela, nous devrions être à l'aise avec l'écriture, la génération et l'utilisation de shellcodes. </p>
            </div>
            <br/>
        </>
    )
}